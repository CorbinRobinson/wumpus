import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class AgentBrain {

	// Don't delete this variable
	private AgentAction nextMove;
	private int actionIterator; // used to iterate through actions list generated by findWayBack
	private ArrayList<AgentAction> actions; // list of actions to do
	private static HashMap<Integer, Boolean> safeSpots; // coords and if its safe or not
	private boolean foundGold;
	private int state; // determines which state of the game we're in
						// 0 = finding path to wumpus, 1 = on way to wumpus, 2 = finding gold, 3 = on
						// way to gold
						// 4 = finding path back, 5 = on way back

	// We reload the brain each time, so this variable needs to be static
	private static int numGamesPlayed = 0;
	private static boolean keyboardPlayOnly = true;

	private int currentNumMoves;

	public AgentBrain() {
		nextMove = null;

		numGamesPlayed++;

		currentNumMoves = 0;

		actionIterator = 0;

		actions = new ArrayList<AgentAction>();

		state = 0;

		foundGold = false;

		safeSpots = new HashMap<Integer, Boolean>();

		for (int x = 1; x < 5; x++) {
			for (int y = 1; y < 5; y++) {
				safeSpots.put(makeCoord(x,y), true);
			}
		}

	}

	public void setNextMove(AgentAction m) {
		if (nextMove != null) {
			System.out.println("Trouble adding move, only allowed to add 1 at a time");
		} else {
			nextMove = m;
		}
	}

	private static int makeCoord(int x, int y) {
		//System.out.println(Integer.parseInt(x + "" + y));
		return Integer.parseInt(x + "" + y);
	}

	private static void changeSpots(int px, int py, boolean b) { // universal safeSpot changer
		int pt = makeCoord(px + 1, py);
		if (safeSpots.containsKey(pt)) // checks out of bounds
			safeSpots.replace(pt, b); // swap t/f value

		pt = makeCoord(px - 1, py);
		if (safeSpots.containsKey(pt))
			safeSpots.replace(pt, b);

		pt = makeCoord(px, py + 1);
		if (safeSpots.containsKey(pt))
			safeSpots.replace(pt, b);

		pt = makeCoord(px, py - 1);
		if (safeSpots.containsKey(pt))
			safeSpots.replace(pt, b);
	}

	private static boolean isSafeMove(GameTile[][] map, int newCol, int newRow) {
		if (1 <= newRow && 1 <= newCol && newRow <= 4 && newCol <= 4) {
			// System.out.println("In bounds");
			// makeThingsVisableAtThisLocation(newRow, newCol);
			if (safeSpots.get(makeCoord(newCol, newRow))) {
				//System.out.println(makeCoord(newCol, newRow) + " is safe");
				return true;
			} else {
				return false;
			}
		} else {
			// System.out.println("Out of bounds");
		}

		return false;
	}

	private ArrayList<AgentAction> findGold(GameTile[][] visableMap, Tuple<Integer, Integer> pLoc) {
		HashMap<Integer, Boolean> bStates = new HashMap<Integer, Boolean>();
		ArrayList<Node> queue = new ArrayList<Node>(); // node queue
		ArrayList<AgentAction> actions = new ArrayList<AgentAction>(); // full set of actions leading to goal states
		bStates.put(Integer.parseInt(pLoc.getX() + "" + pLoc.getY()), true);
		queue.add(new Node(pLoc.getX(), pLoc.getY())); // starting node added into nodes, no parent, doNothing action
		// System.out.println("Starting pos: "+pLoc.getX()+" "+ pLoc.getY());
		int px;
		int py;
		Node currentNode; // iterated node
		// Tuple possibleLoc = new Tuple<Integer, Integer>(0,0);
//		if (visableMap[pLoc.getX()][pLoc.getY()].hasGlitter()) {
//			System.out.println("already here chief");
//			//actions.add(AgentAction.pickupSomething);
//			return actions;
//		}
		for (int i = 0; true; i++) {
			if (i >= queue.size()) { // makes it not crash if no path can be found
				System.out.println("=======================================");
				System.out.println("Cant find gold");
				System.out.println("=======================================");
				foundGold = true;
				actions.add(AgentAction.pickupSomething);
				return actions;
			}

			currentNode = queue.get(i);
			px = currentNode.getX();
			py = currentNode.getY();
			// check goal state
			if (visableMap[py][px].hasGlitter()) {
				actions.add(AgentAction.pickupSomething);
				foundGold = true;
				break;
			}

			if (visableMap[py][px].hasBreeze() || visableMap[py][px].hasStench()) {
				// checks possible pits and wumpus
				changeSpots(px, py, false);
			} else {
				changeSpots(px, py, true);
			}
			// System.out.println("Current pos: "+px+" "+ py);

			// checks up
			//System.out.println("checking up");
			if (!(bStates.containsKey(makeCoord(px, py - 1)))) {
				// checks if we've already been there
				if (visableMap[py - 1][px] != null && isValidMove(visableMap, px, py - 1)) {
					// seen and valid, stops wall error

					// System.out.println("up expanded");
					bStates.put(makeCoord(px, py - 1), true);
					queue.add(new Node(px, py - 1, currentNode, AgentAction.moveUp));
					// check for goal state
					if (visableMap[py - 1][px] == null) {
						break;
					}
				} else if (visableMap[py - 1][px]== null && isSafeMove(visableMap, px, py - 1)) {
					// unseen and safe

					// System.out.println("up expanded");
					bStates.put(makeCoord(px, py - 1), true);
					queue.add(new Node(px, py - 1, currentNode, AgentAction.moveUp));
					// check for goal state
					if (visableMap[py - 1][px] == null) {
						break;
					}
				}
			}

			// checks right
			//System.out.println("checking right");
			if (!(bStates.containsKey(makeCoord(px + 1, py)))) {
				// checks if we've already been there
				if (visableMap[py][px + 1] != null && isValidMove(visableMap, px + 1, py)) {
					// seen and valid, stops wall error

					// System.out.println("up expanded");
					bStates.put(makeCoord(px + 1, py), true);
					queue.add(new Node(px + 1, py, currentNode, AgentAction.moveRight));
					// check for goal state
					if (visableMap[py][px + 1] == null) {
						break;
					}
				} else if (visableMap[py][px + 1]== null && isSafeMove(visableMap, px + 1, py)) {
					// unseen and safe

					// System.out.println("up expanded");
					bStates.put(makeCoord(px + 1, py), true);
					queue.add(new Node(px + 1, py, currentNode, AgentAction.moveRight));
					// check for goal state
					if (visableMap[py][px + 1] == null) {
						break;
					}

				}
			}

			// checks left
			//System.out.println("checking left");
			if (!(bStates.containsKey(makeCoord(px - 1, py)))) {
				// checks if we've already been there
				if (visableMap[py][px - 1] != null && isValidMove(visableMap, px - 1, py)) {
					// seen and valid, stops wall error

					// System.out.println("up expanded");
					bStates.put(makeCoord(px - 1, py), true);
					queue.add(new Node(px - 1, py, currentNode, AgentAction.moveLeft));
					// check for goal state
					if (visableMap[py][px - 1] == null) {
						break;
					}
				} else if (visableMap[py][px - 1] == null && isSafeMove(visableMap, px - 1, py)) {
					// unseen and safe

					// System.out.println("up expanded");
					bStates.put(makeCoord(px - 1, py), true);
					queue.add(new Node(px - 1, py, currentNode, AgentAction.moveLeft));
					// check for goal state
					if (visableMap[py][px - 1] == null) {
						break;
					}

				}
			}

			// checks down
			//System.out.println("checking down");
			if (!(bStates.containsKey(makeCoord(px, py + 1)))) {
				// checks if we've already been there
				if (visableMap[py + 1][px] != null && isValidMove(visableMap, px, py + 1)) {
					// seen and valid, stops wall error

					// System.out.println("up expanded");
					bStates.put(makeCoord(px, py + 1), true);
					queue.add(new Node(px, py + 1, currentNode, AgentAction.moveDown));
					// check for goal state
					if (visableMap[py + 1][px] == null) {
						break;
					}
				} else if (visableMap[py + 1][px]== null && isSafeMove(visableMap, px, py + 1)) {
					// unseen and safe

					// System.out.println("up expanded");
					bStates.put(makeCoord(px, py + 1), true);
					queue.add(new Node(px, py + 1, currentNode, AgentAction.moveDown));
					// check for goal state
					if (visableMap[py + 1][px] == null) {
						break;
					}

				}
			}

//			// checks right
//			System.out.println("checking right");
//			if (isSafeMove(visableMap, px + 1, py) && !(bStates.containsKey(makeCoord(px + 1, py)))) {
//				// System.out.println("right expanded");
//				bStates.put(makeCoord(px + 1, py), true);
//				queue.add(new Node(px + 1, py, currentNode, AgentAction.moveRight));
//				// check for goal state
//				if (visableMap[py][px + 1] == null) {
//					break;
//				}
//
//			}
//
//			// checks down, adds to queue if valid and new node
//			System.out.println("checking down");
//			if (isSafeMove(visableMap, px, py + 1) && !(bStates.containsKey(makeCoord(px, py + 1)))) {
//				// System.out.println("down expanded");
//				bStates.put(makeCoord(px, py + 1), true);
//				queue.add(new Node(px, py + 1, currentNode, AgentAction.moveDown));
//				// check for goal state
//				if (visableMap[py + 1][px] == null) {
//					break;
//				}
//
//			}
//
//			// checks left
//			System.out.println("checking left");
//			if (isSafeMove(visableMap, px - 1, py) && !(bStates.containsKey(makeCoord(px - 1, py)))) {
//				// System.out.println("left expanded");
//				bStates.put(makeCoord(px - 1, py), true);
//				queue.add(new Node(px - 1, py, currentNode, AgentAction.moveLeft));
//				// check for goal state
//				if (visableMap[py][px - 1] == null) {
//					break;
//				}
//
//			}

		}

		// get nodes parents in reverse
		// Stack<AgentAction> stk = new Stack<AgentAction>();
		ArrayList<AgentAction> lineage = new ArrayList<AgentAction>();
		currentNode = queue.get(queue.size() - 1);
		while (true) {
			// System.out.println("("+currentNode.getX()+", "+currentNode.getY()+")");
			lineage.add(currentNode.getAction());
			if (currentNode.getParent() == null)
				break;
			currentNode = currentNode.getParent();
		}
		// System.out.println("stack size: "+lineage.size());
		// convert nodes to actions
		for (int i = lineage.size() - 2; i >= 0; i--) {
			// System.out.println(lineage.get(i).toString());
			actions.add(lineage.get(i));
		}
		// declare victory last action
		// System.out.println("Actions size:" +actions.size());

		return actions;
	}

	private AgentAction isValidShot(GameTile[][] map, int newCol, int newRow) {
		for (int i = 0; i < map.length; i++) { // check east
			if (newCol + i > map.length || map[newRow][newCol + i].isWall()) { // check out of bounds or wall first
				break;
			} else if (map[newRow][newCol + i].hasWumpus()) { // check for wumpus
				return AgentAction.shootArrowEast;
			}
		}
		for (int i = 0; i < map.length; i++) { // check west
			if (newCol - i > map.length || map[newRow][newCol - i].isWall()) {
				break;
			} else if (newCol - i > 0 && map[newRow][newCol - i].hasWumpus()) {
				return AgentAction.shootArrowWest;
			}
		}
		for (int i = 0; i < map.length; i++) { // check south
			if (newRow + i > map.length || map[newRow + i][newCol].isWall()) {
				break;
			} else if (newRow + i < map.length && map[newRow + i][newCol].hasWumpus()) {
				return AgentAction.shootArrowSouth;
			}
		}
		for (int i = 0; i < map.length; i++) { // check north
			if (newRow - i > map.length || map[newRow - i][newCol].isWall()) {
				break;
			} else if (newRow - i > 0 && map[newRow - i][newCol].hasWumpus()) {
				return AgentAction.shootArrowNorth;
			}
		}
		return null;
	}

	// DFS path to kill wumpus
	private ArrayList<AgentAction> killWumpus(GameTile[][] visableMap, Tuple<Integer, Integer> pLoc) {
		HashMap<Integer, Boolean> bStates = new HashMap<Integer, Boolean>();
		ArrayList<Node> queue = new ArrayList<Node>(); // node queue
		ArrayList<AgentAction> actions = new ArrayList<AgentAction>(); // full set of actions leading to goal states
		bStates.put(Integer.parseInt(pLoc.getX() + "" + pLoc.getY()), true);
		queue.add(new Node(pLoc.getX(), pLoc.getY())); // starting node added into nodes, no parent, doNothing action
		// System.out.println("Starting pos: "+pLoc.getX()+" "+ pLoc.getY());
		int px;
		int py;
		Node currentNode; // iterated node
		AgentAction shot = isValidShot(visableMap, pLoc.getX(), pLoc.getY());
		if (shot != null) {
			System.out.println("starting shot " + shot.toString());
			actions.add(shot);
			return actions;
		}
		// Tuple possibleLoc = new Tuple<Integer, Integer>(0,0);
		for (int i = 0; true; i++) {
			if (i >= queue.size()) { // makes it not crash if no path can be found
				System.out.println("=======================================");
				System.out.println("Can't get outta this one");
				System.out.println("=======================================");
				actions.add(AgentAction.declareVictory);
				return actions;
			}
			currentNode = queue.get(i);
			px = currentNode.getX();
			py = currentNode.getY();
			// System.out.println("Current pos: "+px+" "+ py);

			// checks down, adds to queue if valid and new node
			if (isValidMove(visableMap, px, py + 1) && !(bStates.containsKey(Integer.parseInt(px + "" + (py + 1))))) {
				// System.out.println("down expanded");
				bStates.put(Integer.parseInt(px + "" + (py + 1)), true);
				queue.add(new Node(px, py + 1, currentNode, AgentAction.moveDown));
				// check for goal state
				shot = isValidShot(visableMap, px, py + 1);
				if (shot != null) {
					// System.out.println("shot" + shot.toString());
					break;
				}

			}

			// checks left
			if (isValidMove(visableMap, px - 1, py) && !(bStates.containsKey(Integer.parseInt((px - 1) + "" + py)))) {
				// System.out.println("left expanded");
				bStates.put(Integer.parseInt((px - 1) + "" + py), true);
				queue.add(new Node(px - 1, py, currentNode, AgentAction.moveLeft));
				// check for goal state
				shot = isValidShot(visableMap, px - 1, py);
				if (shot != null) {
					// System.out.println("shot" + shot.toString());
					break;
				}

			}
			// checks right
			if (isValidMove(visableMap, px + 1, py) && !(bStates.containsKey(Integer.parseInt((px + 1) + "" + py)))) {
				// System.out.println("right expanded");
				bStates.put(Integer.parseInt((px + 1) + "" + py), true);
				queue.add(new Node(px + 1, py, currentNode, AgentAction.moveRight));
				// check for goal state
				shot = isValidShot(visableMap, px + 1, py);
				if (shot != null) {
					// System.out.println("shot" + shot.toString());
					break;
				}

			}
			// checks up
			if (isValidMove(visableMap, px, py - 1) && !(bStates.containsKey(Integer.parseInt(px + "" + (py - 1))))) {
				// System.out.println("up expanded");
				bStates.put(Integer.parseInt(px + "" + (py - 1)), true);
				queue.add(new Node(px, py - 1, currentNode, AgentAction.moveUp));
				// check for goal state
				shot = isValidShot(visableMap, px - 1, py);
				if (shot != null) {
					// System.out.println("shot" + shot.toString());
					break;
				}

			}
		}
		// get nodes parents in reverse
		// Stack<AgentAction> stk = new Stack<AgentAction>();
		ArrayList<AgentAction> lineage = new ArrayList<AgentAction>();
		currentNode = queue.get(queue.size() - 1);
		while (true) {
			// System.out.println("("+currentNode.getX()+", "+currentNode.getY()+")");
			lineage.add(currentNode.getAction());
			if (currentNode.getParent() == null)
				break;
			currentNode = currentNode.getParent();
		}
		// System.out.println("stack size: "+lineage.size());
		// convert nodes to actions
		for (int i = lineage.size() - 2; i >= 0; i--) {
			// System.out.println(lineage.get(i).toString());
			actions.add(lineage.get(i));
		}
		// declare victory last action
		// System.out.println("Actions size:" +actions.size());
		actions.add(shot);

		return actions;
	}

	// check visableMap to see if nextMove is valid
	private static boolean isValidMove(GameTile[][] map, int newCol, int newRow) {
		if (0 <= newRow && 0 <= newCol && newRow < map.length && newCol < map[0].length
				&& map[newRow][newCol] != null) {
			// System.out.println("In bounds");
			// makeThingsVisableAtThisLocation(newRow, newCol);
			if (map[newRow][newCol].isGround() && !(map[newRow][newCol].hasPit())
					&& !(map[newRow][newCol].hasWumpus())) {
				return true;
			} else {
				return false;
			}
		} else {
			//System.out.println("Out of bounds");
		}

		return false;
	}

	// DFS back to bottom left
	private ArrayList<AgentAction> findWayBack(GameTile[][] visableMap, Tuple<Integer, Integer> pLoc) {
		HashMap<Integer, Boolean> bStates = new HashMap<Integer, Boolean>();
		ArrayList<Node> queue = new ArrayList<Node>(); // node queue
		ArrayList<AgentAction> actions = new ArrayList<AgentAction>(); // full set of actions leading to goal states
		bStates.put(Integer.parseInt(pLoc.getX() + "" + pLoc.getY()), true);
		queue.add(new Node(pLoc.getX(), pLoc.getY())); // starting node added into nodes, no parent, doNothing action
		// System.out.println("Starting pos: " + pLoc.getX() + " " + pLoc.getY());
		int px;
		int py;
		Node currentNode; // iterated node
		// Tuple possibleLoc = new Tuple<Integer, Integer>(0,0);
		if (pLoc.getX() == 1 && pLoc.getY() == visableMap.length - 2) {
			System.out.println("already here chief");
			actions.add(AgentAction.declareVictory);
			return actions;
		}
		for (int i = 0; true; i++) {
			if (i >= queue.size()) { // makes it not crash if no path can be found
				System.out.println("=======================================");
				System.out.println("Can't get outta this one");
				System.out.println("=======================================");
				actions.add(AgentAction.declareVictory);
				return actions;
			}
			currentNode = queue.get(i);
			px = currentNode.getX();
			py = currentNode.getY();
			// System.out.println("Current pos: "+px+" "+ py);

			// checks down, adds to queue if valid and new node
			if (isValidMove(visableMap, px, py + 1) && !(bStates.containsKey(Integer.parseInt(px + "" + (py + 1))))) {
				// System.out.println("down expanded");
				bStates.put(Integer.parseInt(px + "" + (py + 1)), true);
				queue.add(new Node(px, py + 1, currentNode, AgentAction.moveDown));
				// check for goal state
				if (px == 1 && py + 1 == visableMap.length - 2) {
					break;
				}

			}

			// checks left
			if (isValidMove(visableMap, px - 1, py) && !(bStates.containsKey(Integer.parseInt((px - 1) + "" + py)))) {
				// System.out.println("left expanded");
				bStates.put(Integer.parseInt((px - 1) + "" + py), true);
				queue.add(new Node(px - 1, py, currentNode, AgentAction.moveLeft));
				// check for goal state
				if (px - 1 == 1 && py == visableMap.length - 2) {
					break;
				}

			}
			// checks right
			if (isValidMove(visableMap, px + 1, py) && !(bStates.containsKey(Integer.parseInt((px + 1) + "" + py)))) {
				// System.out.println("right expanded");
				bStates.put(Integer.parseInt((px + 1) + "" + py), true);
				queue.add(new Node(px + 1, py, currentNode, AgentAction.moveRight));
				// check for goal state
				if (px + 1 == 1 && py == visableMap.length - 2) {
					break;
				}

			}
			// checks up
			if (isValidMove(visableMap, px, py - 1) && !(bStates.containsKey(Integer.parseInt(px + "" + (py - 1))))) {
				// System.out.println("up expanded");
				bStates.put(Integer.parseInt(px + "" + (py - 1)), true);
				queue.add(new Node(px, py - 1, currentNode, AgentAction.moveUp));
				// check for goal state
				if (px == 1 && py - 1 == visableMap.length - 2) {
					break;
				}

			}

		}
		// get nodes parents in reverse
		// Stack<AgentAction> stk = new Stack<AgentAction>();
		ArrayList<AgentAction> lineage = new ArrayList<AgentAction>();
		currentNode = queue.get(queue.size() - 1);
		while (true) {
			// System.out.println("("+currentNode.getX()+", "+currentNode.getY()+")");
			lineage.add(currentNode.getAction());
			if (currentNode.getParent() == null)
				break;
			currentNode = currentNode.getParent();
		}
		// System.out.println("stack size: "+lineage.size());
		// convert nodes to actions
		for (int i = lineage.size() - 2; i >= 0; i--) {
			// System.out.println(lineage.get(i).toString());
			actions.add(lineage.get(i));
		}
		// declare victory last action
		// System.out.println("Actions size:" +actions.size());
		actions.add(AgentAction.declareVictory);

		return actions;
	}

	// For wumpus world, we do one move at a time
	public AgentAction getNextMove(GameTile[][] visableMap, Tuple<Integer, Integer> pLoc) {
		// Possible things to add to your moves
//		nextMove = AgentAction.doNothing;
//		nextMove = AgentAction.moveDown;
//		nextMove = AgentAction.moveUp;
//		nextMove = AgentAction.moveUp;
//		nextMove = AgentAction.moveLeft;
//		nextMove = AgentAction.pickupSomething;
//		nextMove = AgentAction.declareVictory;
//
//		nextMove = AgentAction.shootArrowNorth;
//		nextMove = AgentAction.shootArrowSouth;
//		nextMove = AgentAction.shootArrowEast;
//		nextMove = AgentAction.shootArrowWest;
//		nextMove = AgentAction.quit;

		// Ideally you would remove all this code, but I left it in so the keylistener
		// would work

		if (keyboardPlayOnly) {
			if (nextMove == null) {
				return AgentAction.doNothing;
			} else {
				AgentAction tmp = nextMove;
				nextMove = null;
				return tmp;
			}

		} else {
			if(numGamesPlayed == 21)
				return AgentAction.quit;
			switch (state) {
			case 0:
				// System.out.println("state: "+state);
				this.actions = findGold(visableMap, pLoc);
				actionIterator = 0;
				//numGamesPlayed++;
				System.out.println("GAME NUMBER: "+ numGamesPlayed);
				// System.out.println("kek");
				state++;
				break;

//			case 1:
//				// System.out.println("state: "+state);
//				if (actionIterator < actions.size() - 1) {
//					break;
//				} else if (actionIterator == actions.size() - 1) {
//					// System.out.println("actually shot wumpus " +
//					// actions.get(actionIterator).toString());
//					state++;
//					break;
//				} else if (actionIterator > actions.size() - 1) {
//					this.actions = killWumpus(visableMap, pLoc);
//					actionIterator = 0;
//					state++;
//					// System.out.println("state: "+state);
//					state++;
//					break;
//				}
//
//			case 2:
//				// System.out.println("state: "+state);
//				this.actions = findGold(visableMap, pLoc);
//				// System.out.println("actions size: " + actions.size());
//				actionIterator = 0;
//				// System.out.println("kek");
//				state++;
//				break;

			case 1:
				if (foundGold) {// will roll over into state 2, finding way back
					// :)
				} else if (actionIterator < actions.size() - 1) { // in the process of moving to a new location
					//System.out.println("finding gold");
					break;
				} else if (actionIterator == actions.size() - 1 && !foundGold) { // last action in list is being
																					// completed, not found gold
					/*
					 * If the last action is about to be completed, and we havent found the gold
					 * then we need to continue discovering the map
					 */
					//System.out.println("finding new discovery");
					this.actions = findGold(visableMap, pLoc);
					actionIterator = 0;
					break;
				} else if (actionIterator > actions.size() - 1) { // occurs when first move is impossible
					//System.out.println("iterator > size");
					if (foundGold) {
						this.actions = findWayBack(visableMap, pLoc);
						actionIterator = 0;
						state++;
						System.out.println("state: " + state);
						state++;
						break;
					} else {
						this.actions = findGold(visableMap, pLoc);
						actionIterator = 0;
						break;
					}

				}

			case 2:
				// System.out.println("state: "+state);
				this.actions = findWayBack(visableMap, pLoc);
				actionIterator = 0;
				state++;

				break;
			}
			//System.out.println("\nGAME NUMBER: " + numGamesPlayed);
			

			return actions.get(actionIterator++);

//			}
		}
	}

}
